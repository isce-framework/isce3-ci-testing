#if !defined(ISCE_IO_IH5_ICC)
#error "IH5.icc is an implementation detail of class IDataset/IGroup/IH5File"
#endif

#include <type_traits>

namespace {
using namespace H5;
using DT = DataType;
using PT = PredType;
using namespace isce3::core;

inline DT getH5StrType(size_t strlen) {
    // HDF5 doesn't seem to support zero-length strings.
    if (strlen == 0) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "string length must be > 0");
    }
    return StrType(PT::C_S1, strlen);
}

inline DT getH5Type(const std::string& str) { return getH5StrType(str.size()); }

template<typename T> DT getH5Type();

template<> inline DT getH5Type<char>() { return PT::NATIVE_CHAR; }
template<> inline DT getH5Type<signed char>() { return PT::NATIVE_UCHAR; }
template<> inline DT getH5Type<unsigned char>() { return PT::NATIVE_SCHAR; }
template<> inline DT getH5Type<short>() { return PT::NATIVE_SHORT; }
template<> inline DT getH5Type<unsigned short>() { return PT::NATIVE_USHORT; }
template<> inline DT getH5Type<int>() { return PT::NATIVE_INT; }
template<> inline DT getH5Type<unsigned int>() { return PT::NATIVE_UINT; }
template<> inline DT getH5Type<long>() { return PT::NATIVE_LONG; }
template<> inline DT getH5Type<unsigned long>() { return PT::NATIVE_ULONG; }
template<> inline DT getH5Type<long long>() { return PT::NATIVE_LLONG; }
template<> inline DT getH5Type<float>() { return PT::NATIVE_FLOAT; }
template<> inline DT getH5Type<double>() { return PT::NATIVE_DOUBLE; }
template<> inline DT getH5Type<long double>() { return PT::NATIVE_LDOUBLE; }

template<typename T> inline DT getH5Type() {

    // Disallow usage for string or char[] objects. We need to know the length of the
    // string in order to construct an appropriate H5::DataType.
    using U = std::decay_t<T>;
    static_assert(!std::is_same<U, std::string>(),
            "getH5Type<std::string>() is not supported -- use"
            " getH5Type(const std::string&) instead");
    static_assert(!std::is_same<U, char*>(),
            "getH5Type<char*>() is not supported -- use"
            " getH5Type(const std::string&) instead");

    if (std::is_same<T, isce3::io::n1bit>()) {
        H5::IntType datatype(H5::PredType::NATIVE_UINT8);
        datatype.setOffset(0);
        datatype.setPrecision(1);
        return datatype;
    }
    if (std::is_same<T, isce3::io::n2bit>()) {
        H5::IntType datatype(H5::PredType::NATIVE_UINT8);
        datatype.setOffset(0);
        datatype.setPrecision(2);
        return datatype;
    }
    if (std::is_same<T, isce3::io::float16>()) {
        H5::FloatType datatype(H5::PredType::NATIVE_FLOAT);
        datatype.setFields(15, 10, 5, 0, 10);
        datatype.setOffset(0);
        datatype.setPrecision(16);
        datatype.setEbias(15);
        datatype.setInpad(H5T_PAD_ZERO);
        return datatype;
    }
    if (std::is_same<T, std::complex<float>>()) {
        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, H5::PredType::NATIVE_FLOAT);
        comp.insertMember("i", sizeof(float), H5::PredType::NATIVE_FLOAT);
        return comp;
    }
    if (std::is_same<T, std::complex<short>>()) {
        H5::CompType comp(2 * sizeof(short));
        comp.insertMember("r", 0, H5::PredType::NATIVE_SHORT);
        comp.insertMember("i", sizeof(short), H5::PredType::NATIVE_SHORT);
        return comp;
    }
    if (std::is_same<T, std::complex<int>>()) {
        H5::CompType comp(2 * sizeof(int));
        comp.insertMember("r", 0, H5::PredType::NATIVE_INT);
        comp.insertMember("i", sizeof(int), H5::PredType::NATIVE_INT);
        return comp;
    }
    if (std::is_same<T, std::complex<isce3::io::float16>>()) {
        H5::FloatType datatype(H5::PredType::NATIVE_FLOAT);
        datatype.setFields(15, 10, 5, 0, 10);
        datatype.setOffset(0);
        datatype.setPrecision(16);
        datatype.setEbias(15);
        datatype.setInpad(H5T_PAD_ZERO);

        H5::CompType comp(2 * sizeof(float));
        comp.insertMember("r", 0, datatype);
        comp.insertMember("i", sizeof(float), datatype);
        return comp;
    }
    if (std::is_same<T, std::complex<double>>()) {
        H5::CompType comp(2 * sizeof(double));
        comp.insertMember("r", 0, H5::PredType::NATIVE_DOUBLE);
        comp.insertMember("i", sizeof(double), H5::PredType::NATIVE_DOUBLE);
        return comp;
    }
    throw isce3::except::InvalidArgument(
            ISCE_SRCINFO(), "Type '" + std::string(typeid(T).name()) +
                                    "' unrecognized for H5 container");
}
} // namespace

template<typename T> inline H5::DataSpace getMemorySpace(const T nbElements) {
    // Create a memory dataSpace describing the dataspace of the memory buffer
    // that will receive the data. It's set up as a 1D array.
    hsize_t memDims[1] = {static_cast<hsize_t>(nbElements)};
    return H5::DataSpace(1, memDims);
}

template<typename T, size_t S>
inline H5::DataSpace getMemorySpace(const std::array<T, S>& dims) {
    // Create a memory dataSpace describing the dataspace of the memory buffer
    hsize_t mem_dims[S];
    for (int i = 0; i < S; i++)
        mem_dims[i] = static_cast<hsize_t>(dims[i]);

    return H5::DataSpace(S, mem_dims);
}

// TODO: All "read" functions below need some templating to tighten the code

/**  @param[in] att  Name of the attribute (optional).
 *  @param[out] v Dataset or attribute scalar value.
 *
 *  If input is not empty, reads the attributes value, otherwise, reads the
 *  dataset scalar value.
 *  For dataset/attributes containing more than one elements, see other
 *  function signature. */
template<typename T>
void isce3::io::IDataSet::read(T& v, const std::string& att) {

    // Check that the parameter that will receive the data read from the file
    // is a numeric variable
    // static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");

    // Check that the dataset/attribute contains a scalar, i.e., rank=0
    if (getRank(att) != 0)
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Dataset/attribute must be scalar");

    if (att.empty()) {
        H5::DataSet::read(&v, getH5Type<T>());
        return;
    }

    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    // Read the attribute from file
    // Order of parameter is reversed compared to dataset read
    openAttribute(att).read(getH5Type<T>(), &v);
}

/** @param[in] start   Raw pointer to array containing the read start location
 * in each dimension.
 *  @param[in] count   Raw pointer to array containing the number of elements to
 * read in each dimension.
 *  @param[in] stride  Raw pointer to array containing the reading stride in
 * each dimension.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller.
 *  start, count, stride must have a number of elements equals to the
 *  rank of the dataset.
 *  If start is nullptr, reading start location in each dimension is 0.
 *  If count is nullptr, full number of element in each dimension is read.
 *  If stride is nullptr, stride defaults to 1 in each dimension.
 *
 * Examples:
 * Dataset contains a 3-bands raster. Dimensions are (100,100,3).
 *
 * To retrieve the full second band:
 * start=[0,0,1], count=[100,100,1], stride=nullptr or [1,1,1].
 *
 * To retrieve the first band, but only every other elements in X direction:
 * start=[0,0,0], count=[50,100,1], stride=[2,1,1]. */
// TODO: check what happen if starts is set but no count - countis defaults to
// full which should be larger than what's available given start

template<typename T>
void isce3::io::IDataSet::read(T* buffer, const int* start, const int* count,
                              const int* stride) {
    // Read dataset subset to memory
    read(buffer, getDataSpace(start, count, stride));
}

/** @param[in] slices Vector containing an std::slice for each dimension of the
 * dataset
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce3::io::IDataSet::read(T* buffer,
                              const std::vector<std::slice>* slices) {
    // Read dataset subset to memory
    read(buffer, getDataSpace(slices));
}

/** @param[in]  gsliceIn std::gslice for subsetting
 *  @param[out] buffer   Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce3::io::IDataSet::read(T* buffer, const std::gslice* gsliceIn) {
    // Read dataset subset to memory
    read(buffer, getDataSpace(gsliceIn));
}

/** @param[in]  dspace DataSpace of the subset to read
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce3::io::IDataSet::read(T* buffer, const H5::DataSpace& dspace) {
    // Check that the selection is valid (no out of bound)
    if (not dspace.selectValid()) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Invalid dataset subselection");
    }

    // Get total number of elements to read
    const hssize_t nbElements = dspace.getSelectNpoints();

    // Format the dataspace of the memory to receive the data read from file
    const H5::DataSpace memspace = getMemorySpace((hsize_t) nbElements);

    // Read the dataset to memory
    H5::DataSet::read(buffer, getH5Type<T>(), memspace, dspace);
}

/** @param[out] buffer std::vector that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T> void isce3::io::IDataSet::read(std::vector<T>& buffer) {
    read(buffer, nullptr, nullptr, nullptr);
}

/** @param[in]  start  std::vector containing the read start location in each
 * dimension.
 *  @param[in]  count  std::vector containing the number of elements to read in
 * each dimension.
 *  @param[in]  stride std::vector containing the reading stride in each
 * dimension.
 *  @param[out] buffer std::vector that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged.  both case the data read is stored at
 *  the beginning of the container.
 *
 *  start, count, stride must have a number of elements equals to the
 *  rank of the dataset.
 *  If start is nullptr, reading start location in each dimension is 0.
 *  If count is nullptr, full number of element in each dimension is read.
 *  If stride is nullptr, stride defaults to 1 in each dimension. */
template<typename T>
void isce3::io::IDataSet::read(std::vector<T>& buffer,
                              const std::vector<int>* start,
                              const std::vector<int>* count,
                              const std::vector<int>* stride) {

    // Format a dataspace according to the input parameters
    const auto dspace = getDataSpace(start ? start->data() : nullptr,
                                     count ? count->data() : nullptr,
                                     stride ? stride->data() : nullptr);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the data to memory
    read(buffer.data(), dspace);
}

/** @param[in] slices Vector containing an std::slice for each dimension of the
 * dataset
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::vector<T>& buffer,
                              const std::vector<std::slice>* slices) {

    // Format a dataspace according to the input parameters
    H5::DataSpace dspace = getDataSpace(slices);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(buffer.data(), dspace);
}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::vector that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::vector<T>& buffer,
                              const std::gslice* gsliceIn) {

    // Format a dataspace according to the input parameters
    H5::DataSpace dspace = getDataSpace(gsliceIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(buffer.data(), dspace);
}

/** @param[out] buffer std::valarray that will receive the full dataset.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T> void isce3::io::IDataSet::read(std::valarray<T>& buffer) {
    read(buffer, nullptr, nullptr, nullptr);
}

/** @param[in] startIn std::valarray containing the read start location in each
 * dimension.
 *  @param[in] countIn std::valarray containing the number of elements to read
 * in each dimension.
 *  @param[in] strideIn std::valarray containing the reading stride in each
 * dimension.
 *  @param[out] buffer std::valarray that will received the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container.
 *
 *  startIn, countIn, strideIn must have a number of elements equals to the
 *  rank of the dataset.
 *  If startIn is nullptr, reading start location in each dimension is 0.
 *  If countIn is nullptr, full number of element in each dimension is read.
 *  If strideIn is nullptr, stride defaults to 1 in each dimension. */
template<typename T>
void isce3::io::IDataSet::read(std::valarray<T>& buffer,
                              const std::valarray<int>* start,
                              const std::valarray<int>* count,
                              const std::valarray<int>* stride) {

    // Format a dataspace according to the input parameters
    H5::DataSpace dspace = getDataSpace(start ? &(*start)[0] : nullptr,
                                        count ? &(*count)[0] : nullptr,
                                        stride ? &(*stride)[0] : nullptr);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
}

/** @param[in] sliceIn sts::valarray containing an std::slice for each dimension
 * of the dataset
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::valarray<T>& buffer,
                              const std::vector<std::slice>* slicesIn) {

    // Format a dataspace according to the input parameters
    H5::DataSpace dspace = getDataSpace(slicesIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
}

/** @param[in] gsliceIn std::gslice for subsetting
 *  @param[out] buffer std::valarray that will receive the read data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::valarray<T>& buffer,
                              const std::gslice* gsliceIn) {

    // Format a dataspace according to the input parameters
    H5::DataSpace dspace = getDataSpace(gsliceIn);

    // Check that vector is sized correctly. Adjust size if necessary
    if (buffer.size() < dspace.getSelectNpoints())
        buffer.resize(dspace.getSelectNpoints());

    // Read the dataset to memory
    read(&buffer[0], dspace);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce3::io::IDataSet::read(T* buffer, const std::string& att) {

    // Check that attribute name is not null or empty
    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    // read(buffer, getH5Type<T>(), att);
    // read(buffer, att);

    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Read the dataset to memory
    a.read(getH5Type<T>(), buffer);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::vector will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::vector<T>& buffer, const std::string& att) {

    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    if (buffer.size() < getNumElements(att))
        buffer.resize(getNumElements(att));

    // read((T*)buffer.data(), getH5Type<T>(), att);
    read((T*) buffer.data(), att);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::valarray will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IDataSet::read(std::valarray<T>& buffer,
                              const std::string& att) {

    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    if (buffer.size() < getNumElements(att))
        buffer.resize(getNumElements(att));

    // read((T*)&buffer[0], getH5Type<T>(), att);
    read((T*) &buffer[0], att);
}

/** @param[in] pointer to buffer to write to dataset.
 *  @param[in] DataSpace object for locating where to write the data in the
 * dataset.
 *  */
template<typename T>
void isce3::io::IDataSet::write(const T* buf, const H5::DataSpace& dspace) {

    // Check that the selection is valid (no out of bound)
    if (!dspace.selectValid()) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Invalid dataset subselection");
    }

    // Construct the memory dataspace (i.e., dataspace of buf). For now, and
    // that may change in a the future, there is no possibility to subset buf.
    // The full content of buf is to be selected. Buf dataspace is set to a 1D
    // array of size equals to the number of elements in the vector.
    H5::DataSpace mspace = getMemorySpace(dspace.getSelectNpoints());

    // write the data to dataset
    H5::DataSet::write(buf, getH5Type<T>(), mspace, dspace);
}

/** @param[in] buf std::vector of data to write to dataset.
 *  It is mandatory that the size of the dataset and the number of elements in
 * the vector matches.
 */
template<typename T> void isce3::io::IDataSet::write(const std::vector<T>& buf) {
    // Construct the dataSpace of the file dataset. It's the full size dataset
    H5::DataSpace dspace = getSpace();

    if (buf.size() != dspace.getSelectNpoints()) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Vector container does not have same number of "
                                "elements as dataset");
    }

    write(buf.data(), dspace);
}

/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] start std::array containing the write start location in each
 * dimension.
 *  @param[in] count std::array containing the number of elements to write in
 * each dimension.
 *  @param[in] stride std::array containing the writing stride in each
 * dimension.
 */
template<typename T, size_t S>
void isce3::io::IDataSet::write(const std::vector<T>& buf,
                               const std::array<int, S>& start,
                               const std::array<int, S>& count,
                               const std::array<int, S>& stride) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    H5::DataSpace dspace =
            getDataSpace(start.data(), count.data(), stride.data());

    write(buf.data(), dspace);
}

/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension
 * of the dataset
 */
template<typename T>
void isce3::io::IDataSet::write(const std::vector<T>& buf,
                               const std::vector<std::slice>* slicesIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    H5::DataSpace dspace = getDataSpace(slicesIn);

    write(buf.data(), dspace);
}

/** @param[in] buf std::vector of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 */
template<typename T>
void isce3::io::IDataSet::write(const std::vector<T>& buf,
                               const std::gslice* gsliceIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    H5::DataSpace dspace = getDataSpace(gsliceIn);

    write(buf.data(), dspace);
}

/** @param[in] buf std::valarray of data to write to dataset.
 *  It is mandatory that the size of the dataset and the number of elements in
 * the valarray matches.
 */
template<typename T>
void isce3::io::IDataSet::write(const std::valarray<T>& buf) {
    // Construct the dataSpace of the file dataset. It's the full size dataset
    H5::DataSpace dspace = getSpace();

    if (buf.size() != dspace.getSelectNpoints()) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Valarray container does not have same number "
                                "of elements as dataset");
    }

    write(&buf[0], dspace);
}

/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] startIn std::array containing the write start location in each
 * dimension.
 *  @param[in] countIn std::array containing the number of elements to write in
 * each dimension.
 *  @param[in] strideIn std::array containing the writing stride in each
 * dimension.
 */
template<typename T, size_t S>
void isce3::io::IDataSet::write(const std::valarray<T>& buf,
                               const std::array<int, S>& startIn,
                               const std::array<int, S>& countIn,
                               const std::array<int, S>& strideIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    H5::DataSpace dspace =
            getDataSpace(startIn.data(), countIn.data(), strideIn.data());
    write(&buf[0], dspace);
}

/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension
 * of the dataset
 */
template<typename T>
void isce3::io::IDataSet::write(const std::valarray<T>& buf,
                               const std::vector<std::slice>* slicesIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    write(&buf[0], getDataSpace(slicesIn));
}

/** @param[in] buf std::valarray of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 */
template<typename T>
void isce3::io::IDataSet::write(const std::valarray<T>& buf,
                               const std::gslice* gsliceIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    write(&buf[0], getDataSpace(gsliceIn));
}

/** @param[in] buf Raw pointer to buffer of data to write to dataset.
 *  The size of the dataset and the number of elements in the buffer must match.
 */
template<typename T>
void isce3::io::IDataSet::write(const T* buf, const size_t sz) {

    // Construct the dataSpace of the file dataset. It's the full size dataset
    H5::DataSpace dspace = getSpace();

    if (sz != dspace.getSelectNpoints()) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Buffer size does not match dataset size");
    }

    write(buf, dspace);
}

/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] startIn std::array containing the write start location in each
 * dimension.
 *  @param[in] countIn std::array containing the number of elements to write in
 * each dimension.
 *  @param[in] strideIn std::array containing the writing stride in each
 * dimension.
 *
 * It the responsability of the caller to make sure that the size of the buffer
 * inferred from the startIn/countIn/strideIn matches the actual size of the
 * buffer.
 */
template<typename T, size_t S>
void isce3::io::IDataSet::write(const T* buf, const std::array<int, S>& startIn,
                               const std::array<int, S>& countIn,
                               const std::array<int, S>& strideIn) {

    // Construct the dataSpace of the file dataset, based on input parameters.
    // Contrary to the memory dataspace, specific parts of the file dataset can
    // be selected for writing into.
    H5::DataSpace dspace =
            getDataSpace(startIn.data(), countIn.data(), strideIn.data());

    write(buf, dspace);

    dspace.close();
}

/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] sliceIn std::vector containing an std::slice for each dimension
 * of the dataset
 *
 * It the responsability of the caller to make sure that the size of the buffer
 * inferred from the startIn/countIn/strideIn matches the actual size of the
 * buffer.
 */
template<typename T>
void isce3::io::IDataSet::write(const T* buf,
                               const std::vector<std::slice>* slicesIn) {
    // Construct the dataSpace of the file dataset, based on inputs. Contrary to
    // the memory dataspace, specific parts of the file dataset can be selected
    // for writing into.
    write(buf, getDataSpace(slicesIn));
}

/** @param[in] buf raw pointer to a buffer of data to write to dataset.
 *  @param[in] gsliceIn std::gslice for subsetting the dataset writing location
 *
 * It the responsability of the caller to make sure that the size of the buffer
 * inferred from the startIn/countIn/strideIn matches the actual size of the
 * buffer.
 */
template<typename T>
void isce3::io::IDataSet::write(const T* buf, const std::gslice* gsliceIn) {
    // Construct the dataSpace of the file dataset, based on inputs. Contrary to
    // the memory dataspace, specific parts of the file dataset can be selected
    // for writing into.
    write(buf, getDataSpace(gsliceIn));
}

/**
 * @param[in] name Name of the dataset attribute to create
 * @param[in] datatype H5 data type of the attribute
 * @param[in] dataspace H5 data space of the attribute
 * @param[in] buffer Raw pointer to attribute data to write
 *
 * This is for any non-string type. String type is handled with a specialized
 * function
 */
template<typename T>
void isce3::io::IDataSet::createAttribute(const std::string& name,
                                         const H5::DataType& datatype,
                                         const H5::DataSpace& dataspace,
                                         const T* buffer) {

    if (name.empty()) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Attribute name cannot be empty");
    }
    if (attrExists(name.c_str())) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + name + "' already exists");
    }

    // Create the attribute and write its data.
    H5::H5Object::createAttribute(name, datatype, dataspace)
            .write(datatype, buffer);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::vector of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce3::io::IDataSet::createAttribute(const std::string& name,
                                                const std::array<T2, S>& dims,
                                                const std::vector<T>& buffer) {

    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), buffer.data());
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::valarray of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void
isce3::io::IDataSet::createAttribute(const std::string& name,
                                    const std::array<T2, S>& dims,
                                    const std::valarray<T>& buffer) {

    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), &buffer[0]);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer Raw pointer buffer to attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce3::io::IDataSet::createAttribute(const std::string& name,
                                                const std::array<T2, S>& dims,
                                                const T* buffer) {

    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), buffer);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::vector of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce3::io::IDataSet::createAttribute(const std::string& name,
                                                const std::vector<T>& data) {

    std::array<hsize_t, 1> dims = {static_cast<hsize_t>(data.size())};
    createAttribute(name, dims, data);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::valarray of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce3::io::IDataSet::createAttribute(const std::string& name,
                                                const std::valarray<T>& data) {
    std::array<hsize_t, 1> dims = {static_cast<hsize_t>(data.size())};
    createAttribute(name, dims, data);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] data Reference to scalar attribute value
 */
template<typename T>
inline void isce3::io::IDataSet::createAttribute(const std::string& name,
                                                const T& data) {

    createAttribute(name, getH5Type<T>(), H5::DataSpace(), &data);
}

namespace isce3 { namespace io {

/**
 * @param[in] name Name of the attribute to create
 * @param[in] data String scalar attribute
 */
template<>
inline void IDataSet::createAttribute(const std::string& name,
                                      const std::string& data) {

    createAttribute(name, getH5Type(data), H5::DataSpace(),
                    data.c_str());
}

}}

/** @param[in] att  Name of the attribute
 *  @param[out] v   Attribute scalar value (numeric type).
 *
 *  Reads the value of the numeral attribute contained in the current group.
 *  For attribute containing more than one element, see other functions
 *  signature. For attribute of string type, see other signature.*/
template<typename T> void isce3::io::IGroup::read(T& v, const std::string& att) {
    // Check that the parameter that will receive the data read from the file
    // is a numeric variable
    // static_assert(std::is_arithmetic<T>::value, "Expected a numeric scalar");
    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }
    // Open the attribute
    H5::Attribute a = openAttribute(att);

    // Get the dataSpace of the attribute
    H5::DataSpace dspace = a.getSpace();

    // If attribute contains a scalar or a 1-element array, read the attribute's
    // value
    if (dspace.getSimpleExtentNdims() != 0) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Dataset/attribute must be scalar");
    }

    a.read(getH5Type<T>(), &v);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer Raw pointer to array that will received the read data.
 *
 *  buffer has to be adequately allocated by caller. */
template<typename T>
void isce3::io::IGroup::read(T* buffer, const std::string& att) {

    // Check that attribute name is not null or empty
    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    openAttribute(att).read(getH5Type<T>(), buffer);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::vector will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IGroup::read(std::vector<T>& buffer, const std::string& att) {

    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' not found");
    }

    if (buffer.size() < getNumElements(att))
        buffer.resize(getNumElements(att));

    read(buffer.data(), att);
}

/** @param[in] att String containing the name of the attribute to read.
 *  @param[out] buffer std::valarray will received the attribute data.
 *
 *  If the output container is undersized compared to the data to read the
 *  function will size it accordingly. If the container is larger than the data
 *  to be read, its size is unchanged. In both case the data read is stored at
 *  the beginning of the container. */
template<typename T>
void isce3::io::IGroup::read(std::valarray<T>& buffer, const std::string& att) {

    if (not attrExists(att)) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + att + "' does not exist");
    }

    if (buffer.size() < getNumElements(att))
        buffer.resize(getNumElements(att));

    read(&buffer[0], att);
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data Scalar (non std::string) data to write to the dataset
 *
 * The dataset is a 1-element dataset
 */
template<typename T>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name, const T& data) {

    const auto dtype = getH5Type<T>();
    H5::DataSet dset = H5::Group::createDataSet(name, dtype, H5::DataSpace());
    dset.write(&data, dtype);
    return dset;
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data std::vector of data to write to the dataset
 *
 * The shape of the dataset is 1D. The number of dataset points is
 * inferred from the size of the input data vector. The dataset type
 * is same as data type.
 */
template<typename T>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name,
                                const std::vector<T>& data) {

    // Default to 1D array dataset with this interface
    std::array<hsize_t, 1> dims {{data.size()}};
    return createDataSet(name, data, dims);
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data std::valarray of data to write to the dataset
 *
 * The shape of the dataset is 1D. The number of dataset points is
 * inferred from the size of the input data valarray. The dataset
 * type is same as data type.
 */
template<typename T>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name,
                                const std::valarray<T>& data) {

    // Default to 1D array dataset with this interface
    std::array<hsize_t, 1> dims {{data.size()}};
    return createDataSet(name, data, dims);
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data Raw pointer to data to write to the dataset
 * @param[in] sz   Number of points in the raw pointer buffer
 *
 * The shape of the dataset is 1D. The dataset type is same as
 * data type.
 */
template<typename T>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name, const T* data,
                                const size_t sz) {

    // Default to 1D array dataset with this interface
    std::array<hsize_t, 1> dims {{sz}};

    return createDataSet(name, data, dims);
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data std::vector of data to write to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name,
                                const std::vector<T>& data,
                                const std::array<T2, S>& dims) {

    IDataSet dset = createDataSet<T>(name, dims);
    dset.write(data);
    return dset;
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data std::valarray of data to write to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name,
                                const std::valarray<T>& data,
                                const std::array<T2, S>& dims) {

    IDataSet dset = createDataSet<T>(name, dims);
    dset.write(data);
    return dset;
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] data Raw pointer to buffer towrite to the dataset
 * @param[in] dims Array containing the size of each dimension of the dataset
 *
 * The dataset type is same as data type.
 */
template<typename T, typename T2, size_t S>
inline isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name, const T* data,
                                const std::array<T2, S>& dims) {

    IDataSet dset = createDataSet<T>(name, dims);
    dset.write(data, dset.getSpace().getSimpleExtentNpoints());
    return dset;
}

/**
 * @param[in] name Name of the dataset to create
 * @param[in] dims Array containing the size of each dimension of the dataset
 * @param[in] chunk 1/0 flag to set dataset chunking
 * @param[in] shuffle 1/0 flag to set byte shuffling
 * @param[in] deflate [0..9] level of dataset compression
 *
 * This interface just create the dataset and does not write any data. Writing
 * is done with the IDataSet write function. To use API specific format
 * (float16, complex,..), this function to create dataset has to be used.
 * Chunking is set to 128x128 chunk on the fastest 2 dimensions only. It is
 * automatically activated if shuffle, deflate or a specfic API format is used.
 * If datatype is of NBIT type (i.e., float16, complex16, n1Bit, n2Bit, the NBIT
 * filter is automatically activated if the chunking is activated.
 */
template<typename T, typename T2, size_t S>
isce3::io::IDataSet
isce3::io::IGroup::createDataSet(const std::string& name,
                                const std::array<T2, S>& dims, const int chunk,
                                const int shuffle, const int deflate) {

    if (name.empty()) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Attribute name cannot be empty");
    }

    // Create the dataspace
    std::vector<hsize_t> dims2(dims.size());
    for (int i = 0; i < dims.size(); i++)
        dims2[i] = (hsize_t) dims[i];
    H5::DataSpace dataSpace((int) dims.size(), dims2.data());

    // Create the dataset creation properties.
    H5::DSetCreatPropList cparms;

    // Adjust dataset creation properties if necessary. This is only the case if
    // one of the three last parameters is activated (!=0).
    if (chunk != 0 || shuffle != 0 || deflate != 0) {

        // No matter which option was used, chunking is mandatory. Only chunk
        // the first 2 dimensions, which corresponds to X, Y. The third
        // dimension (the "band" one) and others doe not get chunked
        std::vector<hsize_t> chunks(dims.size());
        std::fill_n(chunks.data(), dims.size(), 1);
        chunks[0] = chunkSizeX;
        if (dims.size() > 1)
            chunks[1] = chunkSizeY;
        cparms.setChunk(dims.size(), chunks.data());

        // Set the NBIT compression.
        // Only if the datatype is of nbit precision (float16, complex
        // float16,..). Otherwise tests show degraded compression performance
        if (std::is_same<T, isce3::io::float16>::value or
            std::is_same<T, std::complex<isce3::io::float16>>::value or
            std::is_same<T, isce3::io::n1bit>::value or
            std::is_same<T, isce3::io::n2bit>::value)
            cparms.setNbit();

        // Set the byte shuffling if asked for
        if (shuffle != 0)
            cparms.setShuffle();

        // Set the compression level if asked for
        if (deflate != 0) {
            if (deflate < 0) {
                std::cout << "Dataset Deflate compression factor should be "
                             "[0..9] - defaulting to 0"
                          << std::endl;
                cparms.setDeflate(0);
            } else if (deflate > 9) {
                std::cout << "Dataset Deflate compression factor should be "
                             "[0..9] - defaulting to 9"
                          << std::endl;
                cparms.setDeflate(9);
            } else
                cparms.setDeflate(deflate);
        }
    }

    // Create the dataset
    return H5::Group::createDataSet(name, getH5Type<T>(), dataSpace, cparms);
}

/**
 * @param[in] name Name of the group attribute to create
 * @param[in] datatype H5 data type of the attribute
 * @param[in] dataspace H5 data space of the attribute
 * @param[in] buffer Raw pointer to attribute data to write
 *
 * This is for any non-string type. String type is handled with a specialized
 * function
 */
template<typename T>
void isce3::io::IGroup::createAttribute(const std::string& name,
                                       const H5::DataType& datatype,
                                       const H5::DataSpace& dataspace,
                                       const T* buffer) {

    if (name.empty()) {
        throw isce3::except::InvalidArgument(ISCE_SRCINFO(),
                                            "Attribute name cannot be empty");
    }

    if (attrExists(name.c_str())) {
        throw isce3::except::InvalidArgument(
                ISCE_SRCINFO(), "Attribute '" + name + "' already exists");
    }

    // Create the attribute and write its data.
    H5::H5Object::createAttribute(name, datatype, dataspace)
            .write(datatype, buffer);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::vector of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const std::array<T2, S>& dims,
                                              const std::vector<T>& buffer) {
    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), buffer.data());
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer std::valarray of attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const std::array<T2, S>& dims,
                                              const std::valarray<T>& buffer) {
    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), &buffer[0]);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] dims Array containing the size of each dimension of the attribute
 * @param[in] buffer Raw pointer buffer to attribute data to write
 */
template<typename T, typename T2, size_t S>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const std::array<T2, S>& dims,
                                              const T* buffer) {
    createAttribute(name, getH5Type<T>(), getMemorySpace(dims), buffer);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::vector of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const std::vector<T>& data) {
    std::array<hsize_t, 1> dims = {static_cast<hsize_t>(data.size())};
    createAttribute(name, dims, data);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] buffer std::valarray of attribute data to write
 *
 * The shape of the attribute is 1D.
 */
template<typename T>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const std::valarray<T>& data) {
    std::array<hsize_t, 1> dims = {static_cast<hsize_t>(data.size())};
    createAttribute(name, dims, data);
}

/**
 * @param[in] name Name of the attribute to create
 * @param[in] data Reference to scalar attribute value
 */
template<typename T>
inline void isce3::io::IGroup::createAttribute(const std::string& name,
                                              const T& data) {
    createAttribute(name, getH5Type<T>(), H5::DataSpace(), &data);
}

namespace isce3 { namespace io {

/**
 * @param[in] name Name of the attribute to create
 * @param[in] data String scalar attribute
 */
template<>
inline void IGroup::createAttribute(const std::string& name,
                                    const std::string& data) {
    createAttribute(name, getH5Type(data), H5::DataSpace(),
                    data.c_str());
}

}}
